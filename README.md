# Material Management CRUD API - Technical Assessment

## Overview
Build a complete CRUD API for the Material Management module using Spring Boot. This assessment evaluates your ability to work with normalized database schemas and implement production-ready REST APIs.

## Setup using Docker
### Postgres database
`docker run --name postgres-db -e POSTGRES_PASSWORD=admin123 -p 5432:5432 -d postgres:17.6`

Execute the ddl from `src/main/resources/schema.sql` and insert queries from `src/main/resources/starter-data.sql`

### Spring Boot startup
Add VM arguments `-Duser.timezone=UTC` 


## Deliverables
1.  Complete Spring Boot application source code
2.  README with setup instructions
3.  Postman collection or equivalent for API testing [MaterialManagementAPI.postman_collection.json](src/main/resources/MaterialManagementAPI.postman_collection.json)
4.  Brief documentation of design decisions


## Design Decisions

### 1. Layered Architecture
-   The application follows a standard **Controller -> Service -> Repository** layered architecture. This promotes separation of concerns, making the codebase modular, testable, and maintainable.
    -   **Controllers** handle HTTP requests and responses, acting as the API entry point.
    -   **Services** encapsulate business logic and orchestrate operations between controllers and repositories.
    -   **Repositories** manage data persistence and retrieval from the database.

### 2. JPA Entities and DTOs
-   **JPA Entities:** Used to map Java objects directly to database tables, leveraging Hibernate as the JPA provider. Entities are kept clean, focusing solely on persistence concerns.
-   **DTO Pattern:** Data Transfer Objects (DTOs) are used for request and response payloads. This decouples the API contract from the internal data model (JPA entities), allowing for flexible API evolution and preventing direct exposure of database entities.

### 3. Data Validation
-   **Declarative Validation:** Input validation is implemented using `jakarta.validation` annotations (e.g., `@NotBlank`, `@NotNull`, `@Size`) on DTOs. This ensures that incoming data adheres to business rules before processing.
-   **Global Exception Handling:** Validation errors are caught by a `@ControllerAdvice` (`GlobalExceptionHandler`) which transforms them into standardized JSON error responses (HTTP 400 Bad Request).

### 4. Robust Error Handling
-   **Centralized Exception Handling:** A `GlobalExceptionHandler` provides a consistent mechanism for handling various exceptions across the application, returning structured JSON error responses with relevant details (timestamp, status, message, path).
-   **Specific Error Messages:** Custom exceptions like `DuplicateMaterialNameException` are used to provide user-friendly and specific error messages for common scenarios (e.g., unique constraint violations), improving API usability.
-   **Database Integrity:** `DataIntegrityViolationException` is specifically handled to translate low-level database errors into more understandable API responses.

### 5. Soft Delete Implementation
-   Instead of physically removing records, a `soft delete` approach is used via an `is_active` boolean flag in entities. This preserves historical data and simplifies recovery, which is crucial for auditing and data integrity in many business applications.

### 6. Auditing
-   **Spring Data JPA Auditing:** Leveraged Spring Data JPA's auditing capabilities (`@CreatedBy`, `@CreatedDate`, `@LastModifiedBy`, `@LastModifiedDate`) and a custom `AuditorAware` implementation. This automatically populates audit fields (`created_by`, `created_on`, `updated_by`, `updated_on`) for entities, ensuring traceability and accountability without manual intervention in business logic.

### 7. Pagination and Sorting
-   Implemented pagination and sorting for the `GET /api/materials` endpoint using Spring Data JPA's `Pageable` interface. This allows clients to efficiently retrieve large datasets by specifying page number, size, and sort criteria, enhancing API performance and usability.

### 8. Database-Generated IDs
-   **UUID Primary Keys:** Entities use UUIDs as primary keys, generated by the database (`gen_random_uuid()`).
-   **Auto-generated External IDs:** `external_id` fields are also generated by the database using sequences and a specific format (e.g., `MAT-YYYY-NNNN`). JPA entities are configured to allow the database to manage these fields (`insertable = false, updatable = false`), ensuring data consistency and uniqueness.

### 9. Searching & Filtering
-   **Use Elastic Search** Not implemented.